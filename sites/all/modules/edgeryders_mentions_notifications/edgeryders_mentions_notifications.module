<?php
/**
 * @file
 * Code for the Edgeryders mentions notifications feature.
 */

include_once 'edgeryders_mentions_notifications.features.inc';

/**
 * Parse mentions.
 *
 * Code taken from PHP-Instagram project:
 * https://github.com/galen/PHP-Instagram-API/blob/master/Instagram/Helper.php.
 */
function parseMentions($text, \Closure $callback) {
  return preg_replace_callback( '~@(.+?)(?=\b)~', $callback, $text);
}

/**
 * Implements hook_message_subscribe_get_subscribers().
 */
function edgeryders_mentions_notifications_message_subscribe_get_subscribers($message, $subscribe_options, $context) {
  // Extract users from the message.
  if ($message->type == 'edgeryders_mentions_node') {
    try {
      $wrapper = entity_metadata_wrapper('message', $message->mid);
      $uids = array();
      foreach ($wrapper->field_target_users->getIterator() as $delta => $account) {
        // $term_wrapper may now be accessed as a taxonomy term wrapper.
        $uid = $account->getIdentifier();
        $uids[$uid] = array('notifiers' => array('email' => 'email'));
      }
      return $uids;
    }
    catch (EntityMetadataWrapperException $exc) {
      watchdog(
        'edgeryders_mentions_notifications',
        'See '  . __FUNCTION__ . '() <pre>' .  $exc->getTraceAsString() . '</pre>',
         NULL, WATCHDOG_ERROR
      );
    }
  }
}

/**
 * Implements hook_node_insert().
 * In order to respect node access restrictions, we register
 * a shutdown function, because node access grants haven not been written
 * by the time hook_node_insert() is invoked. For more background,
 * see https://drupal.org/node/1918666.
 *
 */
function edgeryders_mentions_notifications_node_insert($node) {
  $message_type = 'edgeryders_mentions_node';

  // We need to clear the static loading cache so that the node body will be
  // ready in time for token replacement for the  message.
  entity_get_controller('node')->resetCache(array($node->nid));

  // Allow other modules to specify an alternative messagge type to use.
  $hook = 'node_insert';

  // Create message.
  try {
    $account = user_load($node->uid);
    $message = message_create($message_type, array('uid' => $account->uid, 'timestamp' => $node->created));

    // Save reference to the node in the node reference field.
    $wrapper = entity_metadata_wrapper('message', $message);
    $node_wrapper = entity_metadata_wrapper('node', $node);
    $body = $node_wrapper->body->value->value(array('decode' => TRUE));

    // Extract mentions.
    $users_mentioned = array();
    $uids = array();
    $wrapper->field_target_nodes[] = $node;
    $mentions = parseMentions($body, function($mention) use (&$users_mentioned, &$uids) {
      if (isset($mention[1])) {
        $account_name = str_replace('_', ' ', $mention[1]);
        $target_account = user_load_by_name($account_name);
        if ($target_account->uid) {
          $users_mentioned[] = $target_account;
          $uids[] = $target_account->uid;
        }
      }
    });
    if (count($users_mentioned)) {
      $wrapper->field_target_users = $users_mentioned;
      $wrapper->save();
      $options = array(
        'rendered fields' => array(
          'message_notify_email_subject' => 'field_message_rendered_subject',
          'message_notify_email_body' => 'field_message_rendered_body',
        ),
      );
      message_subscribe_send_message('node', $node, $message, array(
        'email' => $options,
      ),
      array(
        'notify message owner' => FALSE,
        'entity access' => TRUE,
        'skip context' => TRUE,
      ));
    }
  }
  catch (EntityMetadataWrapperException $exc) {
    watchdog(
      'edgeryders_mentions_notifications',
      'See '  . __FUNCTION__ . '() <pre>' .  $exc->getTraceAsString() . '</pre>',
       NULL, WATCHDOG_ERROR
    );
  }
}

/**
 * Implements hook_comment_insert().
 */
function edgeryders_mentions_notifications_comment_insert_disabled($comment) {
  $account = user_load($comment->uid);
  $node = node_load($comment->nid);
  $message_type = 'commons_notify_comment_created';
  $hook = 'comment_insert';
  if (!isset($node->og_group_ref[LANGUAGE_NONE][0]['target_id'])) {
    $message_type = 'commons_notify_comment_created_no_groups';
  }
  drupal_alter('commons_notify_message_selection', $message_type, $hook, $comment);
  $message = message_create($message_type, array('uid' => $account->uid, 'timestamp' => $comment->created));
  // Save reference to the node in the node reference field, and the
  // "publish" state (i.e. if the node is published or unpublished).
  $wrapper = entity_metadata_wrapper('message', $message);
  $wrapper->field_target_nodes[] = $node;
  $wrapper->field_target_comments[] = $comment;

  // The message should be published only if the node and the comment are
  // both published.
  // @todo: Deal with message publishing/unpublishing.
  /*
  $published = $node->status && $comment->status;
  $wrapper->field_published->set($published);
  */
  $wrapper->save();
  $options = array(
    'rendered fields' => array(
      'message_notify_email_subject' => 'field_message_rendered_subject',
      'message_notify_email_body' => 'field_message_rendered_body',
    ),
  );
  message_subscribe_send_message('comment', $comment, $message, array('email' => $options));
}
