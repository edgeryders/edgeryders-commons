<?php

/**
 * @file
 * Main hooks for anonymous publishing module.
 */

/**
 * Implements hook_help().
 */
function anonymous_publishing_help($path, $arg) {

  switch ($path) {
    case 'admin/help#anonymous_publishing':
      $output = '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('This module lets you permit anonymous publishing on your site, but in a manner that affords some protection against spam.  The major features of Anonymous Publishing are:') . '</p><ol>';
      $output .= '<li>' . t('Users may publish content without first registering an account at the site (also &#8220;lazy registration&#8221; by means of a sub-module).') . '</li>';
      $output .= '<li>' . t('Authenticated users may publish content as an anonymous user.') . '</li></ol>';
      $output .= '<p>' . t('Just enabling the module does nothing.  You also need to enable anonymous publishing for at least one node type.  If you want visitors to be able to create content without registering, you also need to grant the the anonymous user role the permission to &#8220;Create new content&#8220; for at least one node type .  To do this, go to !url for the node module.', array('!url' => 
          l(t('Administration » People » Permissions'),
            'admin/people/permissions',
            array(
              'fragment' => 'module-node',
              'external' => FALSE,
              'attributes' => array(
                'title' => t('Set permissions for anonymous.')
              ),
            )
          )
        )
      ) . '</p>';
      $output .= '<p>' . t('To have &#8220;lazy registration&#8221;, where users may come back and &#8220;claim&#8221; content they\'ve previously posted anonymously, enable the <em>Anonymous publishing claim</em> submodule.') . '</p>';
      $output .= '<p>' . t('See the !url or the file <code>README.txt</code> for a guide to the <em>Anonymous Publishing administration pages</em>.', array('!url' => l(t('community documentation'), 'https://drupal.org/node/2024005'))) . '</p>';
      return $output;
  }
}

/**
 * Implements hook_cron().
 *
 */
function anonymous_publishing_cron() {
  drupal_set_message('DEBUG: hook_cron');
}

/**
 * Check if the content type can be published anonymously.
 *
 * @param text $type
 *   The content type to check
 *
 * @return bool
 *   TRUE if the content type can be published anonymously, FALSE
 *   otherwise.
 */
function anonymous_publishing_content_type_allowed($type) {
  drupal_add_css(drupal_get_path('module', 'anonymous_publishing') . '/anonymous_publishing.css');
  $types = variable_get('anonymous_publishing_types', array());
  //dpm($types);
  return !empty($types[$type]);
}

function _honeyfield_pre_render($element) {
  // Todo 
  return ($element);
}

/**
 * This will wrap the field in a div so it can be hidden with CSS.
 * The wrapper class name is deliberately misleading.
 * The wrapper class need to be set to display_none in css.
 */
function _honeyfield_post_render($content, $element) {
  return '<div class="edit-email-confirm-wrapper">' . $content . '</div>';
}

/**
 * Helper function to make form alterations to input form to add a
 * field for toggling self/alias (authenicated user) or verification
 * email address (anonymous user).
 *
 * @param array $form
 *   The form definition.
 */
function _anonymous_publishing_node_form(&$form) {
  global $user;

  $form['anonymous_publishing'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#tree' => TRUE,
  );

  $options = variable_get('anonymous_publishing_options', array());
  $verifymsg = t('Your content will not appear on this site until your e-mail is verified');
  //debug($form['nid'], 'form nid');
  if ($user->uid) {
    // Allow anon. publishing for auth. users (type 2).
    if ($options['asanon']) {
      $alias = _anonymous_publishing_alias();
      $form['anonymous_publishing']['#title'] = t('Select whether to post as yourself or as %alias', array('%alias' => $alias));
      $form['anonymous_publishing']['options'] = array(
        '#type' => 'radios',
        '#default_value' => 0,
        '#options' => array(
          t('Post as %name', array('%name' => $user->name)),
          t('Post as %alias', array('%alias' => $alias)),
        ),
      );
    }
  }
  //elseif (!$form['nid']['#value']) {
  else {
    $commform = 'comment-form' == $form['#id'];
    $selfactp = ($commform && user_access('skip comment approval')) || (!$commform && $options['sactivate']);
    $form['anonymous_publishing']['#title'] = t('E-mail (your e-mail address will not be shown publicly)');
    $form['anonymous_publishing']['#weight'] = (variable_get('anonymous_publishing_emailweight', 0));
    $form['anonymous_publishing']['email'] = array(
      '#type' => 'textfield',
      '#title' => t('Verification e-mail address'),
      '#description' => $selfactp ? $verifymsg . '.' : $verifymsg . ' ' . t('and the content is approved by an administrator.'),
      '#size' => 60,
      '#maxlength' => EMAIL_MAX_LENGTH,
      '#required' => TRUE,
    );
  }

  if (!count(element_children($form['anonymous_publishing']))) {
    unset($form['anonymous_publishing']);
  }

}

/**
 * Implements hook_form_alter().
 *
 * Changes form for any content type managed by anonymous publishing
 * to add two additional fields. The field for toggling self/alias or
 * verification email address, and a bogus "email_confirm_field".
 */
function anonymous_publishing_form_alter(&$form, &$form_state, $form_id) {
  $types = variable_get('anonymous_publishing_types', array());
  if (substr($form_id, 0, 13) === 'comment_node_') {
    $type = preg_replace('/^comment_node_.*_form$/', 'comment', $form_id);
  }
  else {
    $type = str_replace('_node_form', '', $form_id);
  }
  //dpm($form_id);
  //dpm($type);
  if (isset($form['#form_id']) &&
    $form_id == $form['#form_id'] && anonymous_publishing_content_type_allowed($type)) {
    _anonymous_publishing_node_form($form);
    if (substr($form_id, 0, 13) === 'comment_node_') {
      $form_id = preg_replace('/^comment_node_.*_form$/', 'comment', $form_id);
      if ('comment' == $form_id) {
        $form['#submit'][] = 'anonymous_publishing_comment_submit';
        $form['#validate'][] = 'anonymous_publishing_comment_form_validate';
      }
      // We disable the author field in the comment form.
      $form['author']['name']['#access'] = FALSE;
    }
    //dpm($form);

    $form['email_confirm_field'] = array(
      '#title' => 'Enter your e-mail address (not!):',
      '#type' => 'textfield',
      '#default_value' => '', // set non-empty to simulate 'bot.
      '#size' => 20,
      '#name' => 'email_confirm_field',
      '#description' => t('This field should not even be visible to humans.'),
      '#pre_render' => array('_honeyfield_pre_render'),
      '#post_render' => array('_honeyfield_post_render'),
    );
  }
}


/**
 * Implementation of hook_username_alter().
 */
function anonymous_publishing_username_alter(&$name, $account) {
  //drupal_set_message('anonymous_publishing_username_alter');
  if (isset($account->comment_body) && $account->cid) {
    $alias = db_query("SELECT name FROM {comment} WHERE cid = :cid", array(':cid' => $account->cid))->fetchField();
    if (!empty($alias)) {
      return;
    }
    $email = db_query("SELECT email FROM {anonymous_publishing} WHERE cid = :cid", array(':cid' => $account->cid))->fetchField();
  }
  elseif (isset($account->body) && $account->nid) {
    $email = db_query("SELECT email FROM {anonymous_publishing} WHERE nid = :nid", array(':nid' => $account->nid))->fetchField();
  }
  $options = variable_get('anonymous_publishing_options', array());
  if (isset($options['atalias']) && $options['atalias'] &&  !$account->uid) {
    $name = _anonymous_publishing_alias();
    if (!empty($email)) {
      $alias = db_query("SELECT alias FROM {anonymous_publishing_emails} WHERE email = :email", array(':email' => $email))->fetchField();
      if (!empty($alias))
        $name = $alias;
    }
  }
}

/**
 * Get the system alias for the anonymous user.
 */
function _anonymous_publishing_alias() {
  $alias = variable_get('anonymous', 'Anonymous');
  return $alias;
}

/**
 * Menu callbacks for the tabs on the module admin page.
 */

/**
 * Menu callback: Provide module settings page.
 *
 * @return array
 *   Form.
 */
function anonymous_publishing_admin_settings() {
  //debug($form, 'form');
  $anony = user_load(0);
  $options = variable_get('anonymous_publishing_options', array(
    'sactivate' => 'sactivate',
    'modmail' => 0,
    'blockip' => 0,
    'atalias' => 0,
    'asanon' => 0,
  ));
  $ctypes = variable_get('anonymous_publishing_types', array());
  $active = 0;
  if ($options['sactivate'] && !$options['asanon']) {
    foreach ($ctypes as $ctype => $act) {
      if ('comment' == $ctype && $act) {
        $ua = user_access('post comments', $anony);
        $act = user_access('skip comment approval', $anony);
	if ($act && !$ua) {
          drupal_set_message(t('Anonymous publishers may self-activate comments, but are not allowed to post comments.'), 'warning');
        }
      }
      else {
        $ua = user_access('create ' . $ctype . ' content', $anony);
        //drupal_set_message("DEBUG: [$ctype]:[$act][$ua]");
	if ($act && !$ua) {
          drupal_set_message(t('Anonymous publishers may self-activate !ctypes, but are not allowed to create !ctypes.', array('!ctype' => $ctype)), 'warning');
        }
      }
      if ($act) $active++;
    }
  }
  //dpm($options);
  //drupal_set_message('DEBUG: anonymous_publishing_admin_settings, active. ' . $active);


  $admin = user_load(1);

  $form['anonymous_publishing_ni'] = array(
    '#markup' => '<p><strong>Note</strong>: &#8220;N.I.&#8220; &rArr; Not Implemented.</p>',
  );

  $ctypes = node_type_get_names();
  if (module_exists('comment')) {
    $ctypes['comment'] = 'Comment';
    $ctext = '(+ Comment)';
  }
  else {
    $ctext = '';
  }
  $form['anonymous_publishing_types'] = array(
    '#type' => 'checkboxes',
    '#multiple' => TRUE,
    '#title' => t('Content types !comments where anonymous publishing is managed by this module:', array('!comments' => $ctext)),
    '#default_value' => variable_get('anonymous_publishing_types', array()),
    '#options' => $ctypes,
    '#description' => t('Note: You also need to use node permissions to enable anonymous publishing for the anonymous user role if you want this role to be able to create content.'),
  );
  $alias = _anonymous_publishing_alias();
  
  $form['anonymous_publishing_options'] = array(
    '#type' => 'checkboxes',
    '#multiple' => TRUE,
    '#title' => t('Options:'),
    '#default_value' => variable_get('anonymous_publishing_options', array(
       'sactivate' => 'sactivate',
       'modmail' => 0,
       'blockip' => 0,
       'atalias' => 0,
       'asanon' => 0,
    )),



    '#options' => array(
      'sactivate' => t('Allow self-activation of nodes (i.e. skip administrator approval).'),
      'sactcomm' => t('Allow  self-activation of comments (set &#8220;Skip comment approval&#8221; at !url).',
        array('!url' => 
          l(t('Administration » People » Permissions'),
            'admin/people/permissions',
            array(
              'fragment' => 'module-comment',
              'external' => FALSE,
              'attributes' => array(
                'title' => t('Set permissions for anonymous.')
              ),
            )
          )
        )
      ),
      'modmail' => t('Send e-mail to administrator') . ' ' . t('when anonymous content is created.'),
      'blockip' => t('Use IP-address for blocking.'),
      'atalias' => t('Associate a generated alias with not verified anonymous content.'),
      'asanon' => t('Allow authenticated users to publish as %alias.', array('%alias' => $alias)),
    ),
    '#description' => t('Tick the options you want to enable.'),
  );
  $form['anonymous_publishing_options']['sactcomm'] = array(
    '#disabled' => TRUE,
    '#default_value' => user_access('skip comment approval', $anony),
  );

  //dpm($form['anonymous_publishing_options']['#default_value']['sactcomm']);
  //dpm($form);

  $period = variable_get('anonymous_publishing_period', -1);
  if ($period != -1) {
    $form['anonymous_publishing_options']['atalias'] = array(
      '#disabled' => TRUE,
    );
  }
  $form['anonymous_publishing_moderator'] = array(
    '#type' => 'textfield',
    '#title' => t('Administrator&#39;s e-mail address:'),
    '#size' => 60,
    '#maxlength' => EMAIL_MAX_LENGTH,
    '#default_value' => variable_get('anonymous_publishing_moderator', $admin->mail),
    '#description' => t('Address to use when the') . ' \'' . t('Send e-mail to administrator') . '&hellip;\' ' . t('option is ticked.'),
  );

  $form['anonymous_publishing_emailweight'] = array(
    '#type' => 'textfield',
    '#title' => t('Verification e-mail address field weight:'),
    '#size' => 3,
    '#maxlength' => 3,
    '#default_value' => variable_get('anonymous_publishing_emailweight', 0),
    '#element_validate' => array('element_validate_integer'),
    '#description' => t('Weight of verification e-mail address field on create content form.'),
  );

  $form['anonymous_publishing_autodelhours'] = array(
    '#type' => 'textfield',
    '#title' => t('Number of hours to retain unverified anonymous posts before auto-deletions removes them: (N.I.)'),
    '#size' => 3,
    '#maxlength' => 3,
    '#default_value' => variable_get('anonymous_publishing_autodelhours', 999),
    '#element_validate' => array('element_validate_integer_positive'),
    '#description' => t('Non-verified content will be automatically deleted after this time.'),
  );

  $form['anonymous_publishing_flood'] = array(
    '#type' => 'textfield',
    '#title' => t('Number of anonymous posts allowed from a single user e-mail/ip allowed within an hour:'),
    '#size' => 3,
    '#maxlength' => 2,
    '#default_value' => variable_get('anonymous_publishing_flood', 5),
    '#element_validate' => array('element_validate_integer_positive'),
    '#description' => t('Type &#8220;99&#8221; for no limit.'),
  );

  //dpm($form);
  return system_settings_form($form);
}

/**
 * Helper function; return email subject and body.
 *
 * If admin settings are set, return the overrided settings,
 * else return defaults.
 *
 * @param text $id
 *   The message ID.
 * @param array $variables
 *   An array of substitutions.
 *
 * @return text
 *   The text with the substitution applied.
 */
function _anonymous_publishing_email_text($id, $variables = array()) {
  // Check if an admin setting overrides the default string.
  if ($admin_setting = variable_get('anonymous_publishing_email' . $id, FALSE)) {
    return strtr($admin_setting, $variables);
  }
  // No override, return with default strings.
  else {
    switch ($id) {
      case 'vsubject':
        return t('Please !action your content at !site', $variables);

      case 'action':
        return t('Somebody has created content with title "!title" on !site.  You receive this e-mail because your e-mail address (!email) was given as the verification e-mail address. To !action this content, click or copy this link into the browser: !verification_uri. If this was not you, please ignore this message.', $variables);

      case 'activate':
        return t('If you do not !action within !autodelhours hours, the content will not be published.', $variables);

      case 'verify':
        return t('After you\'ve verified your e-mail address, your content will be placed in the moderation queue. It will be published when it has been approved by an administrator.');
/*
      case 'preview':
        return t('You may manage (view, edit, delete) your unpublished content via the following link: !view_uri.', $variables);
*/
      case 'nsubject':
        return t('Notification about anonymously published content at !site', $variables);

      case 'nbody':
        return t('Anonymous content with title "!title" has been published on !site.  The verification e-mail address was "!email".', $variables);
    }
  }
}

/**
 * Menu callback: Form to change content of email message.
 *
 * @return array
 *   Form.
 */
function anonymous_publishing_admin_email() {
  $form = array();

  $form['#attached']['css'] = array(
    drupal_get_path('module', 'anonymous_publishing') . '/anonymous_publishing_mail.css',
  );

  $form['anonymous_publishing_usersec'] = array(
    '#markup' => '<p>'
    . t('You may edit the following fields to customize the e-mail message sent to non-authenticated users when they create content.')
    . t('The first field is the subject, the rest may go in the body.')
    . '</p>',
  );

  $form['anonymous_publishing_emailvsubject'] = array(
    '#type' => 'textfield',
    '#title' => t('Subject:'),
    '#size' => 60,
    '#maxlength' => 180,
    '#default_value' => variable_get('anonymous_publishing_emailvsubject', _anonymous_publishing_email_text('vsubject')),
  );

  $form['anonymous_publishing_emailaction'] = array(
    '#type' => 'textarea',
    '#title' => t('Introduction:'),
    '#default_value' => variable_get('anonymous_publishing_emailaction', _anonymous_publishing_email_text('action')),
    '#cols' => 60,
    '#rows' => 4,
    '#resizable' => FALSE,
  );

  $form['anonymous_publishing_emailactivate'] = array(
    '#type' => 'textarea',
    '#title' => t('Text to include if auto-deletion is enabled:'),
    '#default_value' => variable_get('anonymous_publishing_emailactivate', _anonymous_publishing_email_text('activate')),
    '#cols' => 60,
    '#rows' => 1,
    '#resizable' => FALSE,
  );

  $form['anonymous_publishing_emailverify'] = array(
    '#type' => 'textarea',
    '#title' => t('Text to include when administrator approval is  mandatory:'),
    '#default_value' => variable_get('anonymous_publishing_emailverify', _anonymous_publishing_email_text('verify')),
    '#cols' => 60,
    '#rows' => 2,
    '#resizable' => FALSE,
  );

/*
  $form['anonymous_publishing_emailpreview'] = array(
    '#type' => 'textarea',
    '#title' => t('Closing:'),
    '#default_value' => variable_get('anonymous_publishing_emailpreview', _anonymous_publishing_email_text('preview')),
    '#cols' => 60,
    '#rows' => 2,
    '#resizable' => FALSE,
  );
*/
  $form['anonymous_publishing_modsec'] = array(
    '#markup' => '<p>'
    . t('You may edit the following fields to customize the e-mail message sent to the administrator when non-authenticated users create content.')
    . t('The first field is the subject, the second is the body.')
    . '</p>',
  );

  $form['anonymous_publishing_emailnsubject'] = array(
    '#type' => 'textfield',
    '#title' => t('Subject (admin):'),
    '#default_value' => variable_get('anonymous_publishing_emailnsubject', _anonymous_publishing_email_text('nsubject')),
    '#size' => 60,
    '#maxlength' => 180,
  );

  $form['anonymous_publishing_emailnbody'] = array(
    '#type' => 'textarea',
    '#title' => t('Body (admin):'),
    '#default_value' => variable_get('anonymous_publishing_emailnbody', _anonymous_publishing_email_text('nbody')),
    '#cols' => 60,
    '#rows' => 2,
    '#resizable' => FALSE,
  );

  $form['anonymous_publishing_vars'] = array(
    '#markup' => '<p>'
    . t('You may use the following tokens in the texts above:')
    . ' <code>!action, !autodelhours, !email, !site, !title, !verification_uri, !view_uri.</code></p>',
  );

  return system_settings_form($form);
}
//    . ' <code>!action, !autodelhours, !email, !site, !verification_uri.</code></p>',


/**
 * Submit for the notify_admin_moderation form.
 */
function anonymous_publishing_admin_moderation_submit($form, &$form_state) {
  unset($form);

  if (!array_key_exists('ap_row', $form_state['values'])) {
    drupal_set_message(t('No nodes.'), 'error');
    return;
  }

  foreach ($form_state['values']['ap_row'] as $settings) {
    if ($settings['cid']) {
      $comm = comment_load($settings['cid']);
      if ($comm) {
        $comm->status = $settings['status'];
        comment_save($comm);
      }
    }
    else {
      $node = node_load($settings['nid']);
      if ($node) {
        $node->status = $settings['status'];
        node_save($node);
      }
    }
  }
  drupal_set_message(t('Revised published status saved.'));
}


/**
 * Menu callback: Form to work with the moderation queue.
 *
 * @return array
 *   Form.
 */
function anonymous_publishing_admin_moderation($form, &$form_state) {

  // Fetch all nodes that has been verified.
  $sql = "SELECT a.apid, a.nid, a.cid, a.verified, a.email, n.title, n.status FROM {anonymous_publishing} a JOIN {node} n ON a.nid = n.nid WHERE a.verified > 0 ORDER BY a.nid DESC";
  $result = db_query($sql);

  $form = array();
  $form['#tree'] = TRUE;
  $form['apm_info'] = array(
    '#markup' => '<p>'
    . t('The following table shows all nodes that have been verified by e-mail, newest first.  You may publish or unpublish by adding or removing a mark in the &#8220;Published&#8221; column.') . ' '
    . t('Then press &#8220;Execute&#8221; to execute the changes.') . '</p>',
  );

  $form['ap_row'] = array();
  while ($row = $result->fetchAssoc()) {
    if ($row['cid']) {
      $comment = db_query("SELECT subject, status FROM {comment} WHERE cid = :cid", array(':cid' => $row['cid']))->fetchAssoc();
      if ($comment) {
        $title = $comment ?  $comment['subject'] : '-deleted-';
        $status = $comment['status'];
      }
      else {
        $title = '-deleted-';
        $status = 0;
      }
    }
    else {
      $title = $row['title'];
      $status = $row['status'];
    }
    $form['ap_row'][$row['apid']] = array();

    $form['ap_row'][$row['apid']]['nidmu'] = array(
      '#markup' => $row['nid'],
    );
    $form['ap_row'][$row['apid']]['cidmu'] = array(
      '#markup' => $row['cid'],
    );
    $form['ap_row'][$row['apid']]['title'] = array(
      '#markup' => $title,
    );
    $form['ap_row'][$row['apid']]['email'] = array(
      '#markup' => $row['email'] ? $row['email'] : t('(redacted)'),
    );
    $form['ap_row'][$row['apid']]['status'] = array(
      '#type' => 'checkbox',
      '#default_value' => $status,
    );
    $form['ap_row'][$row['apid']]['nid'] = array(
      '#type' => 'hidden',
      '#value' => $row['nid'],
    );
    $form['ap_row'][$row['apid']]['cid'] = array(
      '#type' => 'hidden',
      '#value' => $row['cid'],
    );
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Execute'),
  );

  return $form;
}

/**
 * Theme function to theme the moderation form in a table format.
 */
function theme_anonymous_publishing_admin_moderation($variables) {
  $form = $variables['form'];
  $output = drupal_render($form['apm_info']);
  $header = array(
    t('nid'),
    t('cid'),
    t('title'),
    t('e-mail'),
    t('published'),
  );

  $rows = array();
  foreach (element_children($form['ap_row']) as $nid) {
    $row = array();
    foreach (element_children($form['ap_row'][$nid]) as $entry_key) {
      unset($form['ap_row'][$nid][$entry_key]['#title']);
      if (isset($form['ap_row'][$nid][$entry_key]['#type']) && 'hidden' == $form['ap_row'][$nid][$entry_key]['#type']) {
        // hidden field
      }
      else {
        $row[] = drupal_render($form['ap_row'][$nid][$entry_key]);
      }
    }
    $rows[] = $row;
  }

  if (!$rows) {
    $rows[] = array(array(
      'data' => t('There is no verified content to moderate.'),
      'colspan' => 5,
      ));
  }
  $output .= theme('table', array('header' => $header, 'rows' => $rows));
  $output .= drupal_render_children($form);

  return $output;
}

/**
 * Submit for the notify_admin_blocked form.
 */
function anonymous_publishing_admin_blocked_submit($form, &$form_state) {
  unset($form);

  if (!array_key_exists('users', $form_state['values'])) {
    drupal_set_message(t('No users.'), 'error');
    return;
  }

  //dpm($form_state['values']['users']);
  foreach ($form_state['values']['users'] as $auid => $settings) {
    db_update('anonymous_publishing_emails')
    ->fields(array(
      'blocked' => $settings['blocked'],
    ))
    ->condition('auid', $auid)
    ->execute();
  }
  drupal_set_message(t('Blocking status saved.'));
}

/**
 * Menu callback: Form to manage blocking of anonymous users.
 *
 * @return array
 *   $form
 */
function anonymous_publishing_admin_blocked($form, &$form_state) {
  $form = array();

  $form['#tree'] = TRUE;
  $form['apu_info'] = array(
    '#markup' => '<p>'
    . t('The following table shows the generated aliases and the blocked status for all verified e-mail addresses. Toggle the checkbox in the &#8220;Blocked&#8221; colum to block or unblock.') . ' '
    . t('Then press &#8220;Execute&#8221; to execute the changes.') . '</p>',
  );

  // Fetch all emails.
  
  $rows = db_query("SELECT auid, email, alias, ipaddress, blocked FROM {anonymous_publishing_emails} ORDER BY auid DESC")->fetchAll(PDO::FETCH_ASSOC);
  $form['users'] = array();
  foreach ($rows as $row) {
    $form['users'][$row['auid']] = array();
    $form['users'][$row['auid']]['auid'] = array(
      '#markup' => $row['auid'],
    );
    $form['users'][$row['auid']]['alias'] = array(
      '#markup' => $row['alias'],
    );
    $form['users'][$row['auid']]['email'] = array(
      '#markup' => $row['email'],
    );
    $form['users'][$row['auid']]['ip-address'] = array(
      '#markup' => $row['ipaddress'],
    );
    $form['users'][$row['auid']]['blocked'] = array(
      '#type' => 'checkbox',
      '#default_value' => $row['blocked'],
    );
  }

  if ($form['users']) {
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Execute'),
    );
  }

  return $form;
}


/**
 * Theme function to theme the blocked user form in a table format.
 */
function theme_anonymous_publishing_admin_blocked($variables) {
  $form = $variables['form'];
  //dpm($form);
  $output = drupal_render($form['apu_info']);
  $header = array(
    t('auid'),
    t('alias'),
    t('Verification e-mail'),
    t('IP-address'),
    t('Blocked'),
  );

  $rows = array();
  foreach (element_children($form['users']) as $auid) {
    $row = array();
    foreach (element_children($form['users'][$auid]) as $entry_key) {
      unset($form['users'][$auid][$entry_key]['#title']);

      $row[] = drupal_render($form['users'][$auid][$entry_key]);
    }
    $rows[] = $row;
  }

  if (!$rows) {
    $rows[] = array(array(
        'data' => t('There is no e-mail addresses for anonymous publishers on file.'),
        'colspan' => 3,
      ));
  }
  $output .= theme('table', array('header' => $header, 'rows' => $rows));
  $output .= drupal_render_children($form);

  return $output;
}

/**
 * Submit for the notify_admin_spam form.
 */
function anonymous_publishing_admin_spam_submit($form, &$form_state) {
  //dpm($form);
  unset($form);

  if (!array_key_exists('bots', $form_state['values'])) {
    drupal_set_message(t('No bots.'), 'error');
    return;
  }

  //dpm($form_state);
  $moved = 0;
  foreach ($form_state['values']['bots'] as $id => $settings) {
    //dpm($settings);
    //drupal_set_message($id .' &rarr; ' . $settings['block'] .' ' . $settings['ip2']);
    if ($settings['block']) {
      $existp = db_query("SELECT ip FROM {blocked_ips} WHERE ip = :ip", array(':ip' => $settings['ip2']))->fetchAssoc();
      if (FALSE == $existp) {
        $res = db_insert('blocked_ips')
          ->fields(array(
          'ip' => $settings['ip2'],
        ))
        ->execute();
      }
      else {
        $res = TRUE;
      }
      if ($res) {
        $res = db_delete('anonymous_publishing_bots')
          ->condition('ip', $settings['ip2'])
          ->execute();
        $moved++;
      }
    }
  }
  if ($moved) {
    drupal_set_message(t('IP-adresses moved to <code>{blocked_ips}</code>.') );
  }
}


/**
 * Menu callback: Form to manage spambot report.
 *
 * @return array
 *   $form
 */
function anonymous_publishing_admin_spam($form, &$form_state) {
  $form = array();

  $form['#tree'] = TRUE;
  $form['apu_info'] = array(
    '#markup' => '<p>'
    . t('The following table shows the IP-addresses and the average hits per day generated by the ten most aggressive spambots hitting the site. To move the bot\'s IP-address to Drupal <code>{blocked_ips}</code> table, tick the box in the &#8220;Block&#8221; colum.') . ' '
    . t('Then press &#8220;Execute&#8221; to execute the move.') . '</p>'
    . '<p>' . t('As an alternative to the Drupal <code>{blocked_ips}</code> table you may instead deny access to unwanted IP-addresses using the appropriate command in the web server access file.') . '</p>',
  );

  // Fetch all bot reports.
  
  $rows = db_query("SELECT id, ip, visits, first, last FROM {anonymous_publishing_bots} ORDER BY visits DESC LIMIT 10")->fetchAll(PDO::FETCH_ASSOC);
  $form['bots'] = array();
  $now=time();
  foreach ($rows as $row) {
    $freq = $row['visits'] / (($now-$row['first'])/86400);
    //dpm($freq);
    $freq = min(array($freq,$row['visits']));
    $form['bots'][$row['id']] = array();
    $form['bots'][$row['id']]['id'] = array(
      '#markup' => $row['id'],
    );
    $form['bots'][$row['id']]['ip'] = array(
      '#markup' => $row['ip'],
    );
    $form['bots'][$row['id']]['first'] = array(
      '#markup' => format_date($row['first'], 'short'),
    );
    $form['bots'][$row['id']]['last'] = array(
      '#markup' => format_date($row['last'], 'short'),
    );
    $form['bots'][$row['id']]['visits'] = array(
      '#markup' => $row['visits'],
    );
    $form['bots'][$row['id']]['freq'] = array(
      '#markup' => round($freq),
    );
    $form['bots'][$row['id']]['block'] = array(
      '#type' => 'checkbox',
      '#default_value' => FALSE,
    );
    $form['bots'][$row['id']]['ip2'] = array(
      '#type' => 'hidden',
      '#value' => $row['ip'],
    );
  }

  if ($form['bots']) {
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Execute'),
    );
  }
  return $form;
}

/**
 * Theme function to theme the spambot report in a table format.
 */
function theme_anonymous_publishing_admin_spam($variables) {
  $form = $variables['form'];
  //dpm($form);
  $output = drupal_render($form['apu_info']);
  $header = array(
    t('id'),
    t('IP-address'),
    t('First seen'),
    t('Last seen'),
    t('Total hits'),
    t('Daily hits'),
    t('Block'),
  );

  $rows = array();
  foreach (element_children($form['bots']) as $id) {
    $row = array();
    foreach (element_children($form['bots'][$id]) as $entry_key) {
      unset($form['bots'][$id][$entry_key]['#title']);

      if (isset($form['bots'][$id][$entry_key]['#type']) && 'hidden' == $form['bots'][$id][$entry_key]['#type']) {
        // hidden field
      }
      else {
        $row[] = drupal_render($form['bots'][$id][$entry_key]);
      }
    }
    $rows[] = $row;
  }

  if (!$rows) {
    $rows[] = array(array(
        'data' => t('There is no IP-addresses for spambots on file.'),
        'colspan' => 3,
      ));
  }
  $output .= theme('table', array('header' => $header, 'rows' => $rows));
  $output .= drupal_render_children($form);

  return $output;
}

/**
 * Menu callback: Form to manage anonymous publishing real names.
 *
 * @return array
 *   $form
 */
function anonymous_publishing_admin_realnames($form, &$form_state) {
  $form = array();

  $form['#tree'] = TRUE;
  $form['apu_info'] = array(
    '#markup' => '<p>'
    . t('The following table shows the real names and subject lines for nodes published as anonymous.') . '</p>',
  );

  // Fetch all real names.
  $rows = db_query("SELECT a.rnid, a.nid, a.cid, a.realname FROM {anonymous_publishing_realname} a ORDER BY nid")->fetchAll(PDO::FETCH_ASSOC);

  $form['realnames'] = array();
  foreach ($rows as $row) {
    $form['realnames'][$row['rnid']] = array();
    $form['realnames'][$row['rnid']]['rnid'] = array(
      '#markup' => $row['rnid'],
    );
    $form['realnames'][$row['rnid']]['nid'] = array(
      '#markup' => !$row['cid'] ? l($row['nid'], 'node/' . $row['nid']) : $row['nid'],
    );
    $form['realnames'][$row['rnid']]['cid'] = array(
      '#markup' => $row['cid'] ? l($row['cid'], 'comment/' . $row['cid'], array('fragment' => 'comment-' . $row['cid'])) : $row['cid'],
    );
    $form['realnames'][$row['rnid']]['realname'] = array(
      '#markup' => $row['realname'],
    );
    if ($row['cid']) {
      $comm = comment_load($row['cid']);
      $title = $comm ? $comm->subject : '-deleted-';
    }
    else {
      $node = node_load($row['nid']);
      $title = $node ? $node->title : '-deleted-';
    }
    $form['realnames'][$row['rnid']]['subhect'] = array(
      '#markup' => $title,
    );
  }

  return $form;
}

/**
 * Theme function to theme the real names form in a table format.
 */
function theme_anonymous_publishing_admin_realnames($variables) {
  $form = $variables['form'];
  $output = drupal_render($form['apu_info']);
  $header = array(
    t('rnid'),
    t('nid'),
    t('cid'),
    t('real name'),
    t('subject'),
  );

  $rows = array();
  foreach (element_children($form['realnames']) as $nid) {
    $row = array();
    foreach (element_children($form['realnames'][$nid]) as $entry_key) {
      unset($form['realnames'][$nid][$entry_key]['#title']);

      $row[] = drupal_render($form['realnames'][$nid][$entry_key]);
    }
    $rows[] = $row;
  }

  if (!$rows) {
    $rows[] = array(array(
        'data' => t('There is no real names for authenticated users publishing as anonymous on file.'),
        'colspan' => 4,
      ));
  }
  $output .= theme('table', array('header' => $header, 'rows' => $rows));
  $output .= drupal_render_children($form);

  $output .= theme('admin_block', array('title' => 'title', 'content' => 'content'));

  $output .= drupal_render($form['addnode']);

  return $output;
}

/**
 * Submit for the anonymous_publishing_admin_privacy form.
 */
function anonymous_publishing_admin_privacy_submit($form, &$form_state) {
  unset($form);

  //dpm($form_state);
  //dpm($form_state['values']);
  if (!array_key_exists('op', $form_state['values'])) {
    drupal_set_message(t('No operation?'), 'error');
    return;
  }
  if ('Purge now' == $form_state['values']['op']) {
    db_delete('anonymous_publishing')
      ->condition('verified', 1, '=')
      ->execute();

    db_update('anonymous_publishing')
      ->fields(array(
        'akey'  => NULL,
        'email' => '',
      ))
      ->condition('email', '', '!=')
      ->condition('verified', 1, '=')
      ->execute();

    db_truncate('anonymous_publishing_realname')->execute();

    drupal_set_message(t('All information linking identifiers to content have been purged.'));
  }
  elseif ('Save setting' == $form_state['values']['op']) {
    variable_set('anonymous_publishing_period', $form_state['values']['anonymous_publishing_period']);
    drupal_set_message(t('Rentention period updated.'));
  }
  else {
    drupal_set_message(t('Unknown operation.', 'error'));
    return;
  }
  return;
  if ($form_state['values']['users']) {
    foreach ($form_state['values']['users'] as $auid => $settings) {
      db_update('anonymous_publishing_emails')
      ->fields(array(
        'blocked' => $settings['blocked'],
      ))
      ->condition('auid', $auid)
      ->execute();
    }
  }
  drupal_set_message(t('Blocking status saved.'));
}


/**
 * Menu callback: Form to change privacy settings and flush queue.
 *
 * @return array
 *   Form.
 */
function anonymous_publishing_admin_privacy($form, &$form_state) {

  // Count the number of aliases on file.
  $sql = "SELECT a.nid, a.email, m.alias FROM  {anonymous_publishing} a JOIN {anonymous_publishing_emails} m ON a.email = m.email WHERE m.alias <> '' ORDER BY a.nid DESC";
  $aliases = db_query($sql)->rowCount();

  $period = array(
    0 => t('Delete ASAP'),
    3600 => format_interval(3600),
    21600 => format_interval(21600),
    43200 => format_interval(43200),
    86400 => format_interval(86400),
    259200 => format_interval(259200),
    604800 => format_interval(604800),
    2592000 => format_interval(2592000),
    -1 => t('Indefinitely'),
  );

  $form = array();
  $options = variable_get('anonymous_publishing_options', array());
  if (isset($options['atalias']) && $options['atalias']) {
    $disablep = TRUE;
    $warn = '<br><strong>' . t('Note:') . '</strong> ' . t('Purging is incompatible with having a generated alias (main settings).  To purge, you need to turn this setting off.') . '</p>';
  }
  elseif (!$aliases) {
    $warn ='';
    $disablep = FALSE;
  }
  else {
    $warn = '<br>' . t('You have !count linking verification e-mail to content. !these will be deleted when these links are purged.',
      array(
        '!count' => format_plural($aliases, '1 record', '@count records'),
        '!these' => format_plural($aliases, 'This', 'These'),
      )
    ) . '</p>';
    $disablep = FALSE;
  }


  $form['anonymous_publishing_privacy'] = array(
    '#markup' => '<p>For enhanced privacy, you can set a limited retention period for identifying information, or purge this information instantly.' . ' ' . $warn,
  );

  $form['apperiod'] = array(
    '#type' => 'fieldset',
    '#title' => t('Retention period'),
    '#collapsible' => FALSE,
  );
  $form['apperiod']['anonymous_publishing_period'] = array(
    '#type' => 'select',
    '#title' => t('Maximum period to retain record that links verification e-mails and generated aliases to specific content: (N.I.)'),
    '#default_value' => variable_get('anonymous_publishing_period', array(-1)),
    '#options' => $period,
    '#description' => t('Select &#8220;Indefinitely&#8221; to make the records linking verification e-mail to content persistent.  This is the <em>only</em> setting compatible with a persistant alias as byline.'),
  );
  $form['apperiod']['submit'] = array(
    '#type' => 'submit',
    '#disabled' => $disablep,
    '#value' => t('Save setting'),
  );

  $form['appurge'] = array(
    '#type' => 'fieldset',
    '#title' => t('Purge'),
    '#collapsible' => FALSE,
  );
  $form['appurge']['info'] = array(
    '#markup' => t('<p>Press button below to immediately purge all information linking e-mails and generated aliases to anonymously published content.  This operation can not be reversed.</p>'),
  );
  $form['appurge']['submit'] = array(
    '#type' => 'submit',
    '#disabled' => $disablep,
    '#value' => t('Purge now'),
  );

  return $form;
}

/**
 * Implements hook_theme().
 *
 * Register the form data theme into a table for the tabs listed.
 */
function anonymous_publishing_theme() {
  return array(
    'anonymous_publishing_admin_moderation' => array(
      'render element' => 'form',
    ),
    'anonymous_publishing_admin_blocked' => array(
      'render element' => 'form',
    ),
    'anonymous_publishing_admin_spam' => array(
      'render element' => 'form',
    ),
    'anonymous_publishing_admin_realnames' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function anonymous_publishing_permission() {
  return array(
    'administer anonymous_publishing' => array(
      'title' => t('administer anonymous publishing'),
      'description' => t('Administer the anonymous publishing module'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function anonymous_publishing_menu() {

  $items = array();

  $items['admin/config/content/anonymous_publishing'] = array(
    'title' => 'Anonymous publishing',
    'description' => 'Administrator settings for anonymous publishing.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('anonymous_publishing_admin_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('administer anonymous_publishing'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 10,
  );
  $items['admin/config/content/anonymous_publishing/settings'] = array(
    'title' => 'Main settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['admin/config/content/anonymous_publishing/email'] = array(
    'title' => 'Message templates',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('anonymous_publishing_admin_email'),
    'access callback' => 'user_access',
    'access arguments' => array('administer anonymous_publishing'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -9,
  );

  $items['admin/config/content/anonymous_publishing/moderation'] = array(
    'title' => 'Moderation',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('anonymous_publishing_admin_moderation'),
    'access callback' => 'user_access',
    'access arguments' => array('administer anonymous_publishing'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -8,
  );

  $items['admin/config/content/anonymous_publishing/users'] = array(
    'title' => 'Blocking',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('anonymous_publishing_admin_blocked'),
    'access callback' => 'user_access',
    'access arguments' => array('administer anonymous_publishing'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -7,
  );

  $items['admin/config/content/anonymous_publishing/spam'] = array(
    'title' => 'Spam',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('anonymous_publishing_admin_spam'),
    'access callback' => 'user_access',
    'access arguments' => array('administer anonymous_publishing'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -6,
  );

  $items['admin/config/content/anonymous_publishing/realnames'] = array(
    'title' => 'Real names',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('anonymous_publishing_admin_realnames', 2),
    'access callback' => 'user_access',
    'access arguments' => array('administer anonymous_publishing'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -5,
  );

  $items['admin/config/content/anonymous_publishing/privacy'] = array(
    'title' => 'Privacy',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('anonymous_publishing_admin_privacy'),
    'access callback' => 'user_access',
    'access arguments' => array('administer anonymous_publishing'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -4,
  );

  $items['node/%node/verify'] = array(
    'title' => 'Anonymous publishing',
    'description' => 'Process url.',
    'page callback' => 'anonymous_publishing_verify',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'weight' => 10,
  );

  $items['comment/%comment/verify'] = array(
    'title' => 'Anonymous publishing',
    'description' => 'Process url.',
    'page callback' => 'anonymous_publishing_verify',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'weight' => 10,
  );

  return $items;
}

/**
 * Content submission and verification.
 */

/**
 * Page callback: Activate a node or comment published anonymously.
 *
 * This is the page callback for the link sent to the user by email
 * to activate the node.
 */
function anonymous_publishing_verify($nn) {
  //drupal_set_message('beg: anonymous_publishing_verify.');
  //watchdog('anonymous_publishing', 'anonymous_publishing_verify.');
  if (isset($_GET['akey'])) {
    $akey = $_GET['akey'];
  }
  else {
    drupal_set_message(t('No activation key present.'));
    drupal_goto();
  }
  //dpm($nn);

  // Do the key exist?
  $result1 = db_query("SELECT nid, cid, akey, verified, email FROM {anonymous_publishing} WHERE akey = :akey", array (':akey' => $akey))->fetchAssoc();
  $nid = $result1['nid'];
  $cid = $result1['cid'];
  $rkey  = $result1['akey'];
  $vfied = $result1['verified'];
  $email = $result1['email'];
  $at = $akey[0];

  //drupal_set_message($at .'|nid=' . $nid . '|cid=' . $cid . '|akey=' . $akey . '|rkey=' . $rkey . '|email=' . $email . '|verified=' . $vfied .'|');

  if ($akey != $rkey) {
    drupal_set_message(t('Invalid activation key.'), 'error');
    drupal_goto();
  }

  if ($vfied) {
    drupal_set_message(t('Stale activation key.'), 'error');
    drupal_goto();
  }

  $found = FALSE;
  $result = db_query("SELECT email, blocked FROM {anonymous_publishing_emails} WHERE email = :email", array(':email' => $email));
  if ($result) {
    $row = $result->fetchAssoc();
    $found = $row['email'];
  }
  if ($found) {
    if ($row['blocked']) {
      // Hand-moderate if already blocked.
      $at = 'V';
    }
  }
  else {
    $ip  = getenv("REMOTE_ADDR");
    $now = date('Y-m-d');
    $auid = db_insert('anonymous_publishing_emails')
      ->fields(array(
      'email' => $email,
      'ipaddress' => $ip,
      'firstseen' => $now,
      'lastseen'  => $now,
    ))
    ->execute();
    $alias = 'user' . $auid;
    $nmrows = db_update('anonymous_publishing_emails')
      ->fields(array(
      'alias' => $alias,
    ))
    ->condition('auid', $auid, '=')
    ->execute();
  }

  $nmrows = db_update('anonymous_publishing')
    ->fields(array(
    'verified' => 1,
  ))
  ->condition('akey', $akey, '=')
  ->execute();

  //drupal_set_message($at .'|nid=' . $nid . '|cid=' . $cid . '|akey=' . $akey . '|rkey=' . $rkey . '|email=' . $email . '|verified=' . $vfied .'|');
  $vfymsg = t('Thanks for verifying your e-mail,');
  if ($cid && 'A' == $at) {
    $comm_obj = comment_load($cid, TRUE);
    //dpm($comm_obj);
    comment_publish_action($comm_obj);
    comment_save($comm_obj);
    drupal_set_message($vfymsg . ' ' . t('your comment has been published.'));
    drupal_goto('comment/' . $cid, array('fragment' => 'comment-' . $cid));
  }
  elseif ('A' == $at) {
    $node_obj = node_load($nid, NULL, TRUE);
    node_publish_action($node_obj);
    node_save($node_obj);
    drupal_set_message($vfymsg . ' ' . t('your content has been published.'));
    if (node_access('view', $node_obj)) {
      drupal_goto('node/' . $nid . '/view');
    }
  }
  else {
    drupal_set_message($vfymsg . ' ' . t('your content will be published when it has been approved by an administrator.'));
    drupal_goto();
  }

}

/*
 * Implements a custom submit form.
 * Inserts a message that informs the user that administrator approval
 * will not be required if e-mail is validated.
 */
function anonymous_publishing_comment_submit($form, &$form_state) {
  global $_anonymous_publishing_oldfriend;
  global $user;
  if ($user->uid) {
    return;
  }
  if (0 == $_anonymous_publishing_oldfriend || 2 == $_anonymous_publishing_oldfriend) {
    $mm = drupal_get_messages('status', TRUE);
    //dpm($_anonymous_publishing_oldfriend);
    if (2 == $_anonymous_publishing_oldfriend) {
      $key = array_search(t('Your comment has been posted.'), $mm['status']);
      if (FALSE !== $key) {
        $mm['status'][$key] = t('Thank you.  Your content will be published when it has been approved by an administrator.');
      }
    }
    elseif (user_access('skip comment approval')) {
      $key = array_search(t('Your comment has been queued for review by site administrators and will be published after approval.'), $mm['status']);
      if (FALSE !== $key) {
        $mm['status'][$key] = t('Your comment will be published when you validate your e-mail address.');
      }
    }
    foreach ($mm['status'] as $msg) {
      drupal_set_message($msg, 'status');
    }
  }
}

/**
 * Common validation for nodes and comments.
 *
 * Validate the email and ipaddress.
 * _anonymous_publishing_oldfriend record the state of a verified post
 * - 0 means user is not in any way verified
 * - 1 means the post is set to self-activate
 * - 2 means that is have to wait for admin approval
 * - 4 means that it is a verified user posting as anonymous or self
 *
 * @param mixed $content
 *   The content (array or object)
 *
 * @return bool
 *   TRUE if the form validates, FALSE otherwise.
 */
function _anonymous_publishing_content_validate($content) {
  global $user;
  global $_anonymous_publishing_oldfriend;

  $nodep = 'object' == gettype($content);
  $_anonymous_publishing_oldfriend = 0;

  if ($nodep) {
    $isanp = isset($content->anonymous_publishing['email']);
  }
  else {
    $isanp = isset($content['anonymous_publishing']['email']);
  }
  if (!$isanp) {
    return TRUE;
  }
  if ($nodep) {
    $ecfld = $content->email_confirm_field;
    $email = $content->anonymous_publishing['email'];
  }
  else {
    $ecfld = $content['email_confirm_field'];
    $email = $content['anonymous_publishing']['email'];
  }

  if (!empty($ecfld)) {
    drupal_set_message(t('I smell a \'bot.  Please log in to post.'), 'status');
    watchdog('anonymous_publishing', t('Bot with email "@mail".', array('@mail' => $ecfld)));

    $now = time();
    $id = db_query("SELECT id FROM {anonymous_publishing_bots} WHERE ip = :ip", array(':ip' => $user->hostname,))->fetchField();
    if ($id) {
      db_update('anonymous_publishing_bots')
        ->fields(array(
          'last'  => $now,
        ))
        ->expression('visits', 'visits + 1')
        ->condition('id', $id)
        ->execute();
    }
    else {
      $num_updated = db_insert('anonymous_publishing_bots')
        ->fields(array(
        'ip' => $user->hostname,
        'visits' => 1,
        'first' => $now,
        'last'  => $now,
      ))
      ->execute();
    }
    drupal_goto('<front>');
    return FALSE;
  }

  $cntid = $nodep ? $content->nid : $content['cid'];
  if (empty($cntid) && empty($user->uid)) {

    if (!isset($email)) {
      form_set_error('anonymous_publishing][email', t('No e-mail-field. (This should not happen.)'));
      return FALSE;
    }
    if ($err = user_validate_mail($email)) {
      form_set_error('anonymous_publishing][email', t('Please type in a valid e-mail address.'));
      return FALSE;
    }

    if (db_query("SELECT COUNT(*) FROM {users} WHERE mail = :email", array(':email' => $email))->fetchField()) {
      form_set_error('anonymous_publishing][email', t('This e-mail is already in use.  If this you, please log in to post.'));      
      return FALSE;
    }

    $ip    = getenv("REMOTE_ADDR");
    $sql1 = "SELECT auid, email, ipaddress, blocked FROM {anonymous_publishing_emails} WHERE email = '$email'";
    $options = variable_get('anonymous_publishing_options', array());
    if ($options['blockip']) $sql1 .= " OR ipaddress = '$ip'";
    $result = db_query($sql1);
    $nmrows = $result->rowCount();

    // Block if at least one record indicate that this should be blocked.
    $blocked = 0;
    $unknown = 1;
    $now = date('Y-m-d');
    if ($nmrows) {
      foreach ($result as $record) {
        $auid = $record->auid;
	if ($email == $record->email) $unknown = 0;
        $blocked += $record->blocked;
        db_update('anonymous_publishing_emails')
        ->fields(array(
          'lastseen' => $now,
        ))
        ->condition('auid', $auid)
        ->execute();
      }
    }
    else {
      $flood = variable_get('anonymous_publishing_flood');
      $flooded = FALSE;
      if (flood_is_allowed('anonymous_publishing_ip', $flood, 3600)) {
        flood_register_event('anonymous_publishing_ip', 3600);
        if (flood_is_allowed('anonymous_publishing_em', $flood, 3600, $email)) {
          flood_register_event('anonymous_publishing_em', 3600, $email);
        } else {
          $flooded = TRUE;
        }
      } 
      else {
        $flooded = TRUE;
      }

      if ($flooded) {
        form_set_error('anonymous_publishing][email', t('This website only allows ') . $flood . t(' postings of content from non-registered users within one hour.  This restriction may be lifted if you register.'));
        return FALSE;
      }

      // Send activation email.
      return FALSE;
    }
    if ($blocked) {
      form_set_error('anonymous_publishing][email', t('This e-mail/ip-address is banned from posting content on this site.  Please contact the site administrator if you believe this is an error.'));
      return FALSE;
    }

    
    if ($unknown) {
      if (!nodep) {
        drupal_set_message(t('Send activation email.'));
      }
      return FALSE;
    }

    if (($nodep && $options['sactivate']) || (!$nodep && user_access('skip comment approval'))) {
      $_anonymous_publishing_oldfriend = 1;
      drupal_set_message(t('Your email has been activated previously. The content will be published shortly.'));
    }
    else {
      $_anonymous_publishing_oldfriend = 2;
    }
  }
  return TRUE;
}

/**
 * comment_form_validate callback,
 */
function anonymous_publishing_comment_form_validate($form, &$form_state) {
  if (!_anonymous_publishing_content_validate($form_state['values'])) {
    $form_state['status'] = 0;
  }
}

/**
 * Implements hook_comment_presave().
 */
function anonymous_publishing_comment_presave($comment){
  if (isset($comment->anonymous_publishing['email'])) {
    $result = db_query("SELECT email, ipaddress, blocked FROM {anonymous_publishing_emails} WHERE email = :email", array(':email' => $comment->anonymous_publishing['email']))->fetchAssoc();
    if ($result['email']) {
      // blocked status handled by_anonymous_publishing_content_validate()
      $comment->status = COMMENT_PUBLISHED;
    }
    else {
      $comment->status = COMMENT_NOT_PUBLISHED;
    }
  }
  //debug($comment->status, 'presave');
  //debug($result, 'result');
}

/**
 * Implements hook_node_validate().
 */
function anonymous_publishing_node_validate($node) {
  _anonymous_publishing_content_validate($node);
}


/**
 * Implements hook_node_submit().
 */
function anonymous_publishing_node_submit($node) {
  _anonymous_publishing_node_submit($node);
}


/**
 * Implements hook_comment_insert().
 */
function anonymous_publishing_comment_insert($content) {
  global $user;
  global $_anonymous_publishing_oldfriend;
  if (!isset($content->anonymous_publishing['email']) && !isset($content->anonymous_publishing['options'])) {
    // Nothing do to with this module.
    return;
  }

  if (isset($content->anonymous_publishing['options'])) {
    $asanon = $content->anonymous_publishing['options'];
  }
  else {
    $asanon = FALSE;
  }

  if (isset($content->anonymous_publishing['email']) || $asanon) {
    $comm = comment_load($content->cid);
    $comm->uid = 0;
    $comm->name = '';
    $comm->mail = '';
    comment_save($comm);
  }
  if (isset($content->anonymous_publishing['options'])) {
    // Logged in
    if ($content->anonymous_publishing['options']) {
      $result = db_insert('anonymous_publishing_realname')
        ->fields(array(
          'nid' => $content->nid,
          'cid' => $content->cid,
          'realname' => $content->name,
        ))
      ->execute();
    }
    return;
  }

  // Not logged in
  if ($content->status) {
    $comm = comment_load($content->cid);
    $comm->name = '';
    //debug($content->status, '$content->status');
    if (user_access('skip comment approval')) {
      $comm->status = COMMENT_PUBLISHED;
    }
    else {
      $comm->status = COMMENT_NOT_PUBLISHED;
    }
    comment_save($comm);
    $result = db_insert('anonymous_publishing')
      ->fields(array(
        'nid' => $content->nid,
        'cid' => $content->cid,
        'akey' => NULL,
        'verified' => 1,
        'email' => $content->anonymous_publishing['email'],
      ))
      ->execute();
    return;
  }

  $options = variable_get('anonymous_publishing_options', array());

  $at = user_access('skip comment approval') ? 'A' : 'V';
  if (isset($content->anonymous_publishing['email'])) {
    $emailusedtoactivate = $content->anonymous_publishing['email'];
    //$akey = ($_anonymous_publishing_oldfriend) ? NULL : $at . uniqid(md5(uniqid(mt_rand(), TRUE)), TRUE);
    $akey = $at . uniqid(md5(uniqid(mt_rand(), TRUE)), TRUE);
  }
  if (0 == $user->uid && 0 == $content->status) {
    _anonymous_publishing_send_email($content, $akey);
  }

  $_SESSION['anonymous_publishing'] = $content->cid;
  $result = db_insert('anonymous_publishing')
    ->fields(array(
      'nid' => $content->nid,
      'cid' => $content->cid,
      'akey' => $akey,
      'verified' => $_anonymous_publishing_oldfriend,
      'email' => $emailusedtoactivate,
    ))
    ->execute();
}

/**
 * Implements hook_node_insert().
 */
function anonymous_publishing_node_insert($node) {
  global $user;
  global $_anonymous_publishing_oldfriend;

  $options = variable_get('anonymous_publishing_options', array());
  $at = $options['sactivate'] ? 'A' : 'V';

  $asanon = FALSE;
  if (isset($node->anonymous_publishing['options'])) {
    $asanon = $node->anonymous_publishing['options'];
  }

  if (isset($node->anonymous_publishing['email'])) {
    $emailusedtoactivate = $node->anonymous_publishing['email'];
    $akey = ($_anonymous_publishing_oldfriend) ? NULL : $at . uniqid(md5(uniqid(mt_rand(), TRUE)), TRUE);
  }
  else {
    $_anonymous_publishing_oldfriend = 4;
  }

  if (4 != $_anonymous_publishing_oldfriend) {
    $_SESSION['anonymous_publishing'] = $node->nid;
    $result = db_insert('anonymous_publishing')
      ->fields(array(
        'nid' => $node->nid,
        'cid' => 0,
        'akey' => $akey,
        'verified' => $_anonymous_publishing_oldfriend,
        'email' => $emailusedtoactivate,
      ))
      ->execute();
  }

  if (1 == $_anonymous_publishing_oldfriend) {
    // It is already in {forum}, so we need to make sure it is not
    // inserted to avoid PDOException: Duplicate entry vid.
    unset($node->forum_tid);
    $node_obj = node_load($node->nid);
    node_publish_action($node_obj);
    node_save($node_obj);
  }
  elseif (2 == $_anonymous_publishing_oldfriend) {
    drupal_set_message(t('Thank you. Your content will be published when it has been approved by an administrator.'));
  }
  elseif (4 == $_anonymous_publishing_oldfriend) {
    if ($asanon)  {
      $result = db_insert('anonymous_publishing_realname')
        ->fields(array(
          'nid' => $node->nid,
          'cid' => 0,
          'realname' => $node->name,
        ))
        ->execute();
    }
  }
  elseif (0 == $user->uid) {
    _anonymous_publishing_send_email($node, $akey);
  }
}


/**
 * Implements hook_node_update().
 */
function anonymous_publishing_node_update($node) {
  // Empty, don't allow change of authorship for existing nodes.
}


/**
 * Node API submit helper.
 *
 * @param object $node
 *   The node object.
 */
function _anonymous_publishing_node_submit(&$node) {
  global $user;

  $asanon = FALSE;
  if (isset($node->anonymous_publishing['options'])) {
    $asanon = $node->anonymous_publishing['options'];
  }

  $uid = 0;
  if (!$node->nid && !$user->uid) {
    $node->status = 0;
    $node->uid = $uid;
  }
  elseif ($asanon) {
    $node->uid = $uid;
  }
}


/**
 * Send verification email.
 *
 * @param object $node
 *   The node object.
 * @param text $akey
 *   Activation key
 */
function _anonymous_publishing_send_email($node, $akey) {
  global $base_url;
  $options = variable_get('anonymous_publishing_options', array());
  if (isset($node->title)) {
    // node
    $title = $node->title;
    $vfurl = url($base_url . '/node/' . $node->nid . '/verify', array('query' => array('akey' => $akey)));
    $modp = !$options['sactivate'];
  }
  else {
    // comment
    $title = $node->subject;
    if (empty($title)) {
      $title = '';
    }
    $vfurl = url($base_url . '/comment/' . $node->cid . '/verify', array('query' => array('akey' => $akey)));
    $modp = !user_access('skip comment approval');
  }
  $autodelhours = variable_get('anonymous_publishing_autodelhours', '48');

  //dpm($node);
  $from = variable_get('site_mail', ini_get('sendmail_from'));
  $variables = array(
    '!action' => $modp ? t('verify') : t('activate'),
    '!autodelhours' => $autodelhours,
    '!email' => $node->anonymous_publishing['email'],
    '!site' => variable_get('site_name', 'Drupal'),
    '!title' => check_plain($title), // Comments may not have a title.
    '!verification_uri' => $vfurl,
    '!view_uri' => url($base_url . '/node/' . $node->nid . '/view', array('query' => array('akey' => $akey))),
  );

  $params = array();
  $to = $node->anonymous_publishing['email'];
  $subject = _anonymous_publishing_email_text('vsubject', $variables);
  $b1 = _anonymous_publishing_email_text('action', $variables) . "\n\n";
  $b2 = 999 > $autodelhours ?_anonymous_publishing_email_text('activate', $variables) ."\n\n" : '';
  $b3 = $modp ? _anonymous_publishing_email_text('verify', $variables) . "\n\n" : '';
  $b4 = _anonymous_publishing_email_text('preview', $variables) . "\n\n";
  $body = $b1 . $b2  . $b3 . $b4;

  $message = array(
    'id' => 'anonymous_publishing_verify',
    'to' => $to,
    'subject' => $subject,
    'body' => $body,
    'headers' => array(
      'From' => $from,
      'Sender' => $from,
      'Return-Path' => $from,
      'MIME-Version' => '1.0',
      'Content-Type' => 'text/plain; charset=UTF-8; format=flowed; delsp=yes',
      'Content-Transfer-Encoding' => '8bit',
      'X-Mailer' => 'Drupal',
    ),
  );
  $system = drupal_mail_system('anonymous_publishing', 'verify');

  if ($system->mail($message)) {
    drupal_set_message(t('A link and further instructions have been sent to your e-mail address.'));
    watchdog('anonymous_publishing', t('Verification mail sent to @to from @from.', array('@to' => $to, '@from' => $from)));
  }
  else {
    watchdog('anonymous_publishing', 'Error mailing verfication link.');
    drupal_set_message(t('Unable to send mail. Please contact the site admin.'), 'error');
  }

  if ($options['modmail']) {
    $admin = user_load(1);
    $subject = _anonymous_publishing_email_text('nsubject', $variables);
    $body = _anonymous_publishing_email_text('nbody', $variables);
    $body = wordwrap($body);
    $body = str_replace("\n", "\r\n", $body);

    $message = array(
      'id' => 'anonymous_publishing_notify',
      'to' => variable_get('anonymous_publishing_moderator', $admin->mail),
      'subject' => $subject,
      'body' => $body,
      'headers' => array(
        'From' => $from,
        'Sender' => $from,
        'Return-Path' => $from,
        'MIME-Version' => '1.0',
        'Content-Type' => 'text/plain; charset=UTF-8; format=flowed; delsp=yes',
        'Content-Transfer-Encoding' => '8bit',
        'X-Mailer' => 'Drupal',
      ),
    );
    $system = drupal_mail_system('anonymous_publishing', 'notify');
    if (!$system->mail($message)) {
      watchdog('anonymous_publishing', 'Error notifying admin.');
    }
  }
}

/**
 * Node access system integration.
 */

/**
 * Implements hook_node_grants().
 *
 * Tell	 the node access system what GIDs the user belongs to for each realm.
 * $account = account object (anonymous ->uid is 0).
 * $op      = what action is requested
 */
function anonymous_publishing_node_grants($account, $op) {
  
  // watchdog('anonymous_publishing', 'hook_node_grants');
  $grants['anonymous_publishing'] = array(0);

  $nid  = arg(1);
  if (isset($_GET['akey'])) {
    $akey = $_GET['akey'];
  }
  else {
    // Is this a node created in a current session?
    $session = (isset($_SESSION['anonymous_publishing'])) ? $_SESSION['anonymous_publishing'] : 0;
    if ((0 == $account->uid) && ($nid == $session)) {
      $grants['anonymous_publishing'] = array(1);
    }
    return $grants;
  }
  // We need an access key to grant access.
  if (empty($akey)) {
    return $grants;
  }

  $result = db_query("SELECT nid, akey FROM {anonymous_publishing} WHERE nid = :nid", array(':nid' => $nid))->fetchAssoc();
  $rkey  = $result['akey'];
  if ($akey == $rkey) {
    $grants['anonymous_publishing'] = array(1);
  }
  return $grants;
}

/**
 * Implements hook_node_access_records().
 *
 * We only care about the node if it's unpublished and has been published anonymously.
 * And we only want to set grants if they haven't already been set.
 * If not, it is treated just like any other node and we completely ignore it.
 */
function anonymous_publishing_node_access_records($node) {
  global $_anonymous_publishing_oldfriend;

  //dpm($_anonymous_publishing_oldfriend);
  // watchdog('anonymous_publishing', 'hook_node_access_records');
  if (4 == $_anonymous_publishing_oldfriend) {
    return;
  }
  $grants = array();
  // Is this an unpublished node created in a current session?
  $nid  = arg(1);
  $session = (isset($_SESSION['anonymous_publishing'])) ? $_SESSION['anonymous_publishing'] : 0;
  //drupal_set_message("DB nid: $nid session: $session status: $node->status");
  if (!$node->status && ($nid == $session)) {
    //dpm($node);
    $grants[] = array(
      'realm' => 'anonymous_publishing',
      'gid' => 1,
      'grant_view' => TRUE,
      'grant_update' => TRUE,
      'grant_delete' => TRUE,
      'priority' => 0,
    );
    return $grants;
  }

  if (!empty($node->anonymous_publishing)) {

    $nmrows = db_query("SELECT nid, realm FROM {node_access} WHERE nid = :nid", array(':nid' => $node->nid))->rowCount();
    if ($nmrows) {
      return;
    }

    $grants[] = array(
      'realm' => 'anonymous_publishing',
      'gid' => 1,
      'grant_view' => TRUE,
      'grant_update' => TRUE,
      'grant_delete' => TRUE,
      'priority' => 0,
    );
    return $grants;
  }
}

/**
 * Implements hook_node_delete().
 *
 * Delete record associated with the node being deleted.
 */
function anonymous_publishing_node_delete($node) {
  db_query('DELETE FROM {anonymous_publishing} WHERE nid = :nid', array(':nid' => $node->nid));
}


/**
 * Implementation of hook_comment_delete().
 *
 * Delete record associated with the comment being deleted.
 */
function anonymous_publishing_comment_delete($comment) {
  db_query('DELETE FROM {anonymous_publishing} WHERE cid = :cid', array(':cid' => $comment->cid));
}
